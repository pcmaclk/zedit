# 文本渲染与虚拟行布局设计（egui）

> 本文档定义基于 egui 的文本渲染方案、虚拟行布局机制以及  
> 大文件场景下的高性能滚动与显示策略。

---

## 一、设计背景与核心挑战

### 1.1 egui 的本质约束

egui 是 **立即模式 UI（IMGUI）**：

- 每一帧都会重建 UI
- 没有 retained widget 树
- 所有状态必须由应用自己维护

👉 **优势**：简单、无隐藏状态  
👉 **风险**：一旦“每帧干重活”，CPU 直接爆炸

---

## 二、文本渲染的总体目标

### 2.1 性能目标

| 指标 | 目标 |
|----|----|
| 每帧渲染行数 | ≤ 可见行 + 10 |
| 滚动帧率 | ≥ 60 FPS |
| 每帧 Rope 访问 | O(可见行) |
| LayoutJob 构建 | 增量、可缓存 |

---

## 三、核心思想：虚拟行（Virtual Lines）

### 3.1 什么是虚拟行

> **虚拟行 = 文档中的一行文本，但只有在“可见”时才会被渲染**

文档总行数：1,000,000
屏幕可见： ~50 行
→ 实际渲染：50–60 行

yaml
复制代码

---

### 3.2 虚拟行 vs 真实 UI 行

| 概念 | 含义 |
|----|----|
| 文档行 | Rope / mmap 中的逻辑行 |
| 虚拟行 | 当前帧需要绘制的行 |
| UI 行 | egui::Text 中的 Layout |

---

## 四、滚动模型设计

### 4.1 滚动状态结构

```rust
pub struct Viewport {
    pub first_line: usize,
    pub visible_lines: usize,
    pub scroll_offset_px: f32,
}
原则：

Viewport 是 UI 与 Document 的唯一桥梁

UI 不知道 Rope 总大小

4.2 滚动计算流程
text
复制代码
鼠标滚轮 / 拖动
 → 计算 scroll_offset_px
 → 换算 first_line
 → 计算 visible_lines
 → 请求这些行
五、文本布局与渲染流程
5.1 单帧渲染流程（关键）
text
复制代码
Frame start
 → 读取 Viewport
 → for line in visible range
      → Buffer.get_line()
      → 构建 LayoutJob
      → ui.label()
Frame end
⚠️ 禁止在此流程中：

遍历全文

访问 Rope 的全量 API

做语法解析

六、LayoutJob 构建策略
6.1 为什么必须用 LayoutJob
支持多段颜色

支持等宽字体

支持高亮 token

rust
复制代码
let mut job = egui::text::LayoutJob::default();
6.2 LayoutJob 缓存设计
rust
复制代码
HashMap<LineIndex, CachedLayout>
缓存策略：

未修改行 → 直接复用

修改行 → 只 invalidate 当前行

滚动 → 优先复用

七、与语法高亮的协作
7.1 高亮只作用于可见行
text
复制代码
请求第 N 行
 → 检查是否有缓存高亮
 → 无 → Syntect 分析该行
 → 转换为 LayoutJob
7.2 高亮状态传播（有限）
只允许向后传播有限行（如 50 行）

禁止跨文件全量传播

八、大文件（Large Buffer）渲染策略
8.1 显示规则
Buffer 类型	渲染方式
Small	完整 LayoutJob
Medium	可见行
Large	单色文本

8.2 Large Buffer 渲染路径
text
复制代码
mmap slice
 → 查找 '\n'
 → ui.monospace()
不使用 LayoutJob

不使用 Syntect

不使用缓存

九、行号栏（Gutter）设计
9.1 Gutter 原则
行号不参与高亮

与文本区域独立滚动

固定宽度

text
复制代码
| 123 | let x = 10;
| 124 | println!("{}", x);
十、光标与选择（只读说明）
光标与选择 不在本文件中实现，但必须遵守以下约束：

光标位置 = 文档坐标

UI 只渲染，不保存逻辑

不允许 UI 推断文本结构

十一、禁止行为清单（极重要）
❌ 每帧构建全文 LayoutJob

❌ 每帧 Rope::to_string()

❌ 在 egui 帧中调用 Syntect 全量分析

❌ 大文件走普通渲染路径

十二、调试与验证清单
 滚动 100MB 文件不卡

 行号与文本同步

 修改单行只刷新该行

 空闲 CPU < 1%

 FPS 稳定 ≥ 60

markdown
复制代码
